import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FileText, 
  RefreshCw, 
  Edit3, 
  Save, 
  X, 
  Download, 
  Users, 
  Globe, 
  Loader2,
  ChevronDown,
  ChevronRight,
  Clock,
  Bot,
  Type,
  Code
} from 'lucide-react';
import { Crepe } from '@milkdown/crepe';
import { useChat } from '../contexts/ChatContext';
import { useAuth } from '../contexts/AuthContext';
import { klusterAI } from '../services/klusterAI';

interface SummaryData {
  id: string;
  type: 'overall' | 'user';
  content: string;
  lastUpdated: Date;
  messageCount: number;
  autoGenerated: boolean;
}

interface SummaryPaneProps {
  onClose: () => void;
}

const SummaryPane: React.FC<SummaryPaneProps> = ({ onClose }) => {
  const { currentRoom, currentUser } = useChat();
  const { user } = useAuth();
  const [activeTab, setActiveTab] = useState<'overall' | 'user'>('overall');
  const [isEditing, setIsEditing] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [editMode, setEditMode] = useState<'rich' | 'markdown'>('rich');
  const [markdownContent, setMarkdownContent] = useState('');
  const [summaries, setSummaries] = useState<Record<string, SummaryData>>({
    overall: {
      id: 'overall',
      type: 'overall',
      content: '',
      lastUpdated: new Date(),
      messageCount: 0,
      autoGenerated: false
    },
    user: {
      id: 'user',
      type: 'user',
      content: '',
      lastUpdated: new Date(),
      messageCount: 0,
      autoGenerated: false
    }
  });
  const [isExpanded, setIsExpanded] = useState(true);
  const editorRef = useRef<HTMLDivElement>(null);
  const crepeRef = useRef<Crepe | null>(null);
  const markdownTextareaRef = useRef<HTMLTextAreaElement>(null);

  const currentSummary = summaries[activeTab];

  // Initialize Milkdown Crepe editor
  const initializeEditor = useCallback(async () => {
    if (!editorRef.current || !isEditing || editMode !== 'rich') return;

    try {
      // Clean up existing editor
      if (crepeRef.current) {
        crepeRef.current.destroy();
        crepeRef.current = null;
      }

      // Create new Crepe instance
      const crepe = new Crepe({
        root: editorRef.current,
        defaultValue: currentSummary.content || '# Summary\n\nStart writing your summary here...',
        placeholder: 'Write your summary here...',
        features: {
          [Crepe.Feature.CodeMirror]: true,
          [Crepe.Feature.ListItem]: true,
          [Crepe.Feature.LinkTooltip]: true,
          [Crepe.Feature.ImageBlock]: false, // Disable images for summaries
          [Crepe.Feature.TableBlock]: true,
          [Crepe.Feature.Copilot]: false, // Disable AI copilot since we have our own
        },
        featureConfigs: {
          [Crepe.Feature.Toolbar]: {
            config: [
              ['bold', 'italic', 'strikethrough'],
              ['heading', 'bulletList', 'orderedList'],
              ['link', 'blockquote', 'code', 'codeBlock'],
              ['table', 'divider'],
              ['undo', 'redo']
            ]
          }
        }
      });

      await crepe.create();
      crepeRef.current = crepe;

      // Set initial content if available
      if (currentSummary.content) {
        crepe.setMarkdown(currentSummary.content);
      }

    } catch (error) {
      console.error('Failed to initialize Milkdown editor:', error);
    }
  }, [isEditing, editMode, currentSummary.content]);

  // Auto-resize markdown textarea
  useEffect(() => {
    if (markdownTextareaRef.current && isEditing && editMode === 'markdown') {
      const textarea = markdownTextareaRef.current;
      textarea.style.height = 'auto';
      textarea.style.height = `${textarea.scrollHeight}px`;
    }
  }, [markdownContent, isEditing, editMode]);

  // Initialize editor when entering edit mode
  useEffect(() => {
    if (isEditing && editMode === 'rich') {
      // Small delay to ensure DOM is ready
      setTimeout(initializeEditor, 100);
    }

    return () => {
      if (crepeRef.current) {
        crepeRef.current.destroy();
        crepeRef.current = null;
      }
    };
  }, [initializeEditor]);

  // Load summaries from localStorage on mount
  useEffect(() => {
    if (currentRoom) {
      const savedSummaries = localStorage.getItem(`chatmind_summaries_${currentRoom.id}`);
      if (savedSummaries) {
        try {
          const parsed = JSON.parse(savedSummaries);
          setSummaries(prev => ({
            ...prev,
            ...Object.fromEntries(
              Object.entries(parsed).map(([key, value]: [string, any]) => [
                key,
                {
                  ...value,
                  lastUpdated: new Date(value.lastUpdated)
                }
              ])
            )
          }));
        } catch (error) {
          console.warn('Failed to load saved summaries:', error);
        }
      }
    }
  }, [currentRoom]);

  // Save summaries to localStorage
  const saveSummaries = (newSummaries: Record<string, SummaryData>) => {
    if (currentRoom) {
      localStorage.setItem(`chatmind_summaries_${currentRoom.id}`, JSON.stringify(newSummaries));
    }
  };

  const generateSummary = async (type: 'overall' | 'user') => {
    if (!currentRoom || !user) return;

    setIsGenerating(true);
    try {
      const messages = currentRoom.messages;
      const filteredMessages = type === 'user' 
        ? messages.filter(m => m.userId === user.id && !m.isAI)
        : messages.filter(m => !m.isAI); // Exclude AI messages from overall summary

      if (filteredMessages.length === 0) {
        const emptyContent = type === 'user' 
          ? "# My Contributions\n\nNo messages from you yet in this conversation. Start participating to see your summary here!"
          : "# Chat Summary\n\nNo messages in this conversation yet. Start chatting to generate a summary!";
        
        const newSummary: SummaryData = {
          id: type,
          type,
          content: emptyContent,
          lastUpdated: new Date(),
          messageCount: 0,
          autoGenerated: true
        };

        setSummaries(prev => {
          const updated = { ...prev, [type]: newSummary };
          saveSummaries(updated);
          return updated;
        });
        return;
      }

      // Prepare context for AI
      const contextMessages = filteredMessages.slice(-20).map(m => ({
        role: 'user' as const,
        content: `${m.userName}: ${m.content}`
      }));

      const prompt = type === 'user'
        ? `Create a concise summary of ${user.name}'s contributions to this chat conversation. Focus on:
- Key points they made
- Questions they asked
- Decisions or actions they proposed
- Their main areas of focus

Format as markdown with bullet points. Keep it under 300 words.`
        : `Create a comprehensive summary of this chat conversation in the room "${currentRoom.name}". Include:
- Main topics discussed
- Key decisions made
- Important questions raised
- Action items or next steps
- Key participants and their contributions

Format as markdown with clear sections and bullet points. Keep it under 400 words.`;

      const summaryContent = await klusterAI.generateResponse([
        { role: 'user', content: prompt },
        ...contextMessages
      ], currentRoom.name);

      const newSummary: SummaryData = {
        id: type,
        type,
        content: summaryContent,
        lastUpdated: new Date(),
        messageCount: filteredMessages.length,
        autoGenerated: true
      };

      setSummaries(prev => {
        const updated = { ...prev, [type]: newSummary };
        saveSummaries(updated);
        return updated;
      });

    } catch (error) {
      console.error('Failed to generate summary:', error);
      // Show error in summary
      const errorContent = `# Summary Generation Failed\n\nUnable to generate summary at this time. Please try again later.\n\n**Error:** ${error instanceof Error ? error.message : 'Unknown error'}`;
      
      const errorSummary: SummaryData = {
        id: type,
        type,
        content: errorContent,
        lastUpdated: new Date(),
        messageCount: 0,
        autoGenerated: true
      };

      setSummaries(prev => {
        const updated = { ...prev, [type]: errorSummary };
        saveSummaries(updated);
        return updated;
      });
    } finally {
      setIsGenerating(false);
    }
  };

  const startEditing = () => {
    setMarkdownContent(currentSummary.content);
    setIsEditing(true);
  };

  const saveEdit = async () => {
    let content = '';
    
    if (editMode === 'rich' && crepeRef.current) {
      try {
        content = await crepeRef.current.getMarkdown();
      } catch (error) {
        console.error('Failed to get markdown from editor:', error);
        content = currentSummary.content; // Fallback to current content
      }
    } else {
      content = markdownContent;
    }

    const updatedSummary: SummaryData = {
      ...currentSummary,
      content,
      lastUpdated: new Date(),
      autoGenerated: false
    };

    setSummaries(prev => {
      const updated = { ...prev, [activeTab]: updatedSummary };
      saveSummaries(updated);
      return updated;
    });

    setIsEditing(false);
    setMarkdownContent('');
  };

  const cancelEdit = () => {
    setIsEditing(false);
    setMarkdownContent('');
  };

  const downloadSummary = () => {
    const content = currentSummary.content;
    const filename = `${currentRoom?.name || 'chat'}-${activeTab}-summary.md`;
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const formatLastUpdated = (date: Date) => {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    
    if (diffMinutes < 1) return 'Just now';
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffHours < 24) return `${diffHours}h ago`;
    const diffDays = Math.floor(diffHours / 24);
    return `${diffDays}d ago`;
  };

  const shouldShowAutoRefresh = () => {
    if (!currentRoom) return false;
    const currentMessageCount = activeTab === 'user' 
      ? currentRoom.messages.filter(m => m.userId === user?.id && !m.isAI).length
      : currentRoom.messages.filter(m => !m.isAI).length;
    
    return currentMessageCount > currentSummary.messageCount + 5; // Show if 5+ new messages
  };

  if (!currentRoom) {
    return (
      <div className="w-80 bg-white border-l border-gray-200 flex flex-col shadow-subtle">
        <div className="p-4 border-b border-gray-200 bg-gray-50">
          <div className="flex items-center justify-between">
            <h3 className="font-semibold text-gray-900">Summary</h3>
            <button
              onClick={onClose}
              className="btn-ghost p-1"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
        <div className="flex-1 flex items-center justify-center p-8">
          <div className="text-center text-gray-500">
            <FileText className="w-12 h-12 mx-auto mb-3 text-gray-300" />
            <p>Join a room to view summaries</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-80 bg-white border-l border-gray-200 flex flex-col shadow-subtle">
      {/* Header */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between mb-3">
          <div className="flex items-center gap-2">
            <FileText className="w-5 h-5 text-primary-600" />
            <h3 className="font-semibold text-gray-900">Summary</h3>
          </div>
          <div className="flex items-center gap-1">
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="btn-ghost p-1"
              title={isExpanded ? "Collapse" : "Expand"}
            >
              {isExpanded ? (
                <ChevronDown className="w-4 h-4" />
              ) : (
                <ChevronRight className="w-4 h-4" />
              )}
            </button>
            <button
              onClick={onClose}
              className="btn-ghost p-1"
              title="Close summary"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>

        {isExpanded && (
          <>
            {/* Tab Switcher */}
            <div className="flex bg-gray-100 rounded-lg p-1 mb-3">
              <button
                onClick={() => setActiveTab('overall')}
                className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md transition-colors ${
                  activeTab === 'overall'
                    ? 'bg-white text-gray-900 shadow-subtle'
                    : 'text-gray-600 hover:text-gray-900'
                }`}
              >
                <Globe className="w-4 h-4" />
                Overall
              </button>
              <button
                onClick={() => setActiveTab('user')}
                className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md transition-colors ${
                  activeTab === 'user'
                    ? 'bg-white text-gray-900 shadow-subtle'
                    : 'text-gray-600 hover:text-gray-900'
                }`}
              >
                <Users className="w-4 h-4" />
                Mine
              </button>
            </div>

            {/* Action Buttons */}
            <div className="flex gap-2 mb-3">
              <button
                onClick={() => generateSummary(activeTab)}
                disabled={isGenerating}
                className="flex-1 btn-primary flex items-center justify-center gap-2 text-sm py-2"
              >
                {isGenerating ? (
                  <Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <Bot className="w-4 h-4" />
                )}
                {isGenerating ? 'Generating...' : 'AI Summary'}
              </button>
              
              {!isEditing ? (
                <button
                  onClick={startEditing}
                  className="btn-ghost px-3 py-2 text-sm"
                  title="Edit summary"
                >
                  <Edit3 className="w-4 h-4" />
                </button>
              ) : (
                <div className="flex gap-1">
                  <button
                    onClick={saveEdit}
                    className="px-3 py-2 text-sm text-success-600 hover:text-success-800 hover:bg-success-50 rounded-lg transition-colors"
                    title="Save changes"
                  >
                    <Save className="w-4 h-4" />
                  </button>
                  <button
                    onClick={cancelEdit}
                    className="btn-ghost px-3 py-2 text-sm"
                    title="Cancel editing"
                  >
                    <X className="w-4 h-4" />
                  </button>
                </div>
              )}
            </div>

            {/* Edit Mode Switcher */}
            {isEditing && (
              <div className="flex bg-gray-100 rounded-lg p-1 mb-3">
                <button
                  onClick={() => setEditMode('rich')}
                  className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md transition-colors ${
                    editMode === 'rich'
                      ? 'bg-white text-gray-900 shadow-subtle'
                      : 'text-gray-600 hover:text-gray-900'
                  }`}
                >
                  <Type className="w-4 h-4" />
                  Rich Text
                </button>
                <button
                  onClick={() => setEditMode('markdown')}
                  className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 text-sm font-medium rounded-md transition-colors ${
                    editMode === 'markdown'
                      ? 'bg-white text-gray-900 shadow-subtle'
                      : 'text-gray-600 hover:text-gray-900'
                  }`}
                >
                  <Code className="w-4 h-4" />
                  Markdown
                </button>
              </div>
            )}

            {/* Auto-refresh notification */}
            {shouldShowAutoRefresh() && !isGenerating && (
              <div className="bg-primary-50 border border-primary-200 rounded-lg p-3 mb-3">
                <div className="flex items-start gap-2">
                  <RefreshCw className="w-4 h-4 text-primary-600 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-primary-800 text-sm font-medium">New messages available</p>
                    <p className="text-primary-700 text-xs mt-1">
                      Generate a new summary to include recent messages
                    </p>
                  </div>
                </div>
              </div>
            )}

            {/* Summary Info */}
            <div className="flex items-center justify-between text-xs text-gray-500 mb-3">
              <div className="flex items-center gap-1">
                <Clock className="w-3 h-3" />
                <span>{formatLastUpdated(currentSummary.lastUpdated)}</span>
              </div>
              <div className="flex items-center gap-2">
                {currentSummary.autoGenerated && (
                  <span className="bg-primary-100 text-primary-700 px-2 py-0.5 rounded-full text-xs font-medium border border-primary-200">
                    AI Generated
                  </span>
                )}
                <button
                  onClick={downloadSummary}
                  className="btn-ghost p-1"
                  title="Download as markdown"
                >
                  <Download className="w-3 h-3" />
                </button>
              </div>
            </div>
          </>
        )}
      </div>

      {/* Content */}
      {isExpanded && (
        <div className="flex-1 overflow-y-auto scrollbar-thin">
          {isEditing ? (
            <div className="p-4">
              {editMode === 'rich' ? (
                <div className="border border-gray-300 rounded-lg overflow-hidden shadow-subtle">
                  <div 
                    ref={editorRef}
                    className="min-h-96 prose prose-sm max-w-none"
                    style={{ 
                      '--crepe-editor-padding': '16px',
                      '--crepe-editor-min-height': '384px'
                    } as React.CSSProperties}
                  />
                </div>
              ) : (
                <textarea
                  ref={markdownTextareaRef}
                  value={markdownContent}
                  onChange={(e) => setMarkdownContent(e.target.value)}
                  placeholder="Write your summary in markdown..."
                  className="w-full min-h-96 p-3 input-field resize-none text-sm font-mono"
                  style={{ lineHeight: '1.5' }}
                />
              )}
              
              {editMode === 'markdown' && (
                <div className="mt-3 text-xs text-gray-500">
                  <p className="mb-1 font-medium">Markdown supported:</p>
                  <ul className="list-disc list-inside space-y-0.5 text-gray-400">
                    <li># Headers</li>
                    <li>**Bold** and *italic*</li>
                    <li>- Bullet points</li>
                    <li>[Links](url)</li>
                    <li>`code` and ```code blocks```</li>
                  </ul>
                </div>
              )}
            </div>
          ) : (
            <div className="p-4">
              {currentSummary.content ? (
                <div 
                  className="prose prose-sm max-w-none"
                  dangerouslySetInnerHTML={{ 
                    __html: currentSummary.content
                      .replace(/^# (.*$)/gim, '<h1 class="text-lg font-bold text-gray-900 mb-3">$1</h1>')
                      .replace(/^## (.*$)/gim, '<h2 class="text-base font-semibold text-gray-900 mb-2">$1</h2>')
                      .replace(/^### (.*$)/gim, '<h3 class="text-sm font-semibold text-gray-900 mb-2">$1</h3>')
                      .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>')
                      .replace(/\*(.*?)\*/g, '<em class="italic text-gray-800">$1</em>')
                      .replace(/`(.*?)`/g, '<code class="bg-gray-100 text-gray-800 px-1 py-0.5 rounded text-xs font-mono">$1</code>')
                      .replace(/^- (.*$)/gim, '<li class="text-sm text-gray-700">$1</li>')
                      .replace(/\n\n/g, '</p><p class="text-sm text-gray-700 mb-3 leading-relaxed">')
                      .replace(/^(.*)$/gim, '<p class="text-sm text-gray-700 mb-3 leading-relaxed">$1</p>')
                  }}
                />
              ) : (
                <div className="text-center py-12">
                  <FileText className="w-12 h-12 text-gray-300 mx-auto mb-3" />
                  <h4 className="font-medium text-gray-900 mb-2">No summary yet</h4>
                  <p className="text-sm text-gray-500 mb-4">
                    {activeTab === 'user' 
                      ? "Generate a summary of your contributions to this conversation"
                      : "Generate an overall summary of this chat conversation"
                    }
                  </p>
                  <button
                    onClick={() => generateSummary(activeTab)}
                    disabled={isGenerating}
                    className="btn-primary inline-flex items-center gap-2 text-sm"
                  >
                    {isGenerating ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Bot className="w-4 h-4" />
                    )}
                    Generate Summary
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SummaryPane;